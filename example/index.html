<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit"></script>
    <link href="https://cdn.jsdelivr.net/npm/@xterm/xterm/css/xterm.min.css" rel="stylesheet">
    <script src="wasm_exec.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: black;
        }
        .terminal-container {
            /* this is important */
            overflow: hidden;
            background-color: black;
        }
    </style>
</head>
<body>
<div class="terminal-container" style="height: 100%; width: 100%;">
    <div id="terminal" style="height: 100%"></div>
</div>
<script>
    // Store the last known ETag
    let lastETag = localStorage.getItem('wasmETag') || '';

    function initTerminal() {
        // Check if bubbletea is initialized
        if (globalThis.bubbletea_resize === undefined || globalThis.bubbletea_read === undefined || globalThis.bubbletea_write === undefined) {
            setTimeout(() => {
                console.log("waiting for bubbletea");
                initTerminal();
            }, 500);
            return;
        }

        const term = new Terminal();
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal'));

        // Register terminal resize
        fitAddon.fit();
        window.addEventListener('resize', () => (fitAddon.fit()));

        // Focus terminal
        term.focus();

        // Initial resize
        bubbletea_resize(term.cols, term.rows)

        // Read from bubbletea and write to xterm
        setInterval(() => {
            const read = bubbletea_read();
            if (read && read.length > 0) {
                term.write(read);
            }
        }, 100);

        // Resize on terminal resize
        term.onResize((size) => (bubbletea_resize(size.cols, size.rows)));

        // Write xterm output to bubbletea
        term.onData((data) => (bubbletea_write(data)));
    }

    async function loadWasm(retryCount = 0) {
        const maxRetries = 10;
        const baseDelay = 1000; // Start with 1 second delay
        
        try {
            console.log(`Attempting to load WASM (attempt ${retryCount + 1})`);
            
            // Create headers object with ETag if we have one
            const headers = new Headers();
            if (lastETag) {
                headers.append('If-None-Match', lastETag);
                console.log(`Using ETag: ${lastETag}`);
            }
            
            // Fetch the WASM file with ETag headers
            const response = await fetch("./bubbletea.wasm", { headers });
            
            // Store the new ETag if present
            const newETag = response.headers.get('ETag');
            if (newETag) {
                console.log(`Received new ETag: ${newETag}`);
                lastETag = newETag;
                localStorage.setItem('wasmETag', newETag);
            }
            
            // If we got a 304 Not Modified, we can use the cached version
            if (response.status === 304) {
                console.log('WASM file not modified, using cached version');
                // We need to fetch again without the If-None-Match header to get the actual content
                const cachedResponse = await fetch("./bubbletea.wasm");
                const go = new Go();
                const result = await WebAssembly.instantiateStreaming(cachedResponse, go.importObject);
                go.run(result.instance).then(() => {
                    console.log("wasm finished (cached)");
                });
                initTerminal();
                return true;
            }
            
            // Otherwise, process the new WASM file
            const go = new Go();
            const result = await WebAssembly.instantiateStreaming(response, go.importObject);
            
            // Run wasm
            go.run(result.instance).then(() => {
                console.log("wasm finished");
            });

            // Init terminal
            initTerminal();
            
            return true;
        } catch (error) {
            console.error(`Failed to load WASM (attempt ${retryCount + 1}):`, error);
            
            if (retryCount < maxRetries) {
                // Calculate exponential backoff delay with jitter
                const delay = baseDelay * Math.pow(1.5, retryCount) * (0.9 + Math.random() * 0.2);
                console.log(`Retrying in ${Math.round(delay / 1000)} seconds...`);
                
                // Wait and retry
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(loadWasm(retryCount + 1));
                    }, delay);
                });
            } else {
                console.error(`Failed to load WASM after ${maxRetries} attempts. Giving up.`);
                return false;
            }
        }
    }

    function init() {
        // Start the WASM loading process with retry mechanism
        loadWasm().then(success => {
            if (!success) {
                console.error("Could not initialize the application. Please check your connection and reload the page.");
            }
        });
    }

    // Start the initialization process
    init();
</script>
</body>
</html>